---
output:
  reprex::reprex_document:
    venue: "gh"
    advertise: FALSE
    session_info: TRUE
    style: TRUE
    comment: "#;-)"
    tidyverse_quiet: FALSE
    std_out_err: TRUE
knit: reprex::reprex_render
---

## Init

# Packages

```{r, eval = requireNamespace("tidyverse", quietly = TRUE)}
library(tidyverse)
```

# Inital functions
- healthy = 2, sick = 1, and dead = 0, w
```{R}
b1 <- function(t){
    return(12*30000*0.15*(1.015^t))
}

a <- 3.5 * (10^(-4))
b <- 7 * (10^(-8))
c <- 0.157
mu <- function(t) {
    return(a + b*exp(c*t))
}
```

## Assignment 1A
```{R}
spot_rates = read.csv('./interest_rates.csv')
colnames(spot_rates) = c("y",'r')

D <- function(s, t) {
    rates <- spot_rates
    rates$s <- s
    rates$t <- t
    rates <- rates %>% filter(spot_rates["y"] >= s - 1 & spot_rates["y"] < t)
    r_cum <- apply(rates, 1, function(x) (min(x["y"] + 1, x["t"]) - max(x["s"], x["y"])) * x["r"])
    return(exp(-sum(r_cum)))
}

```

## Assigment 1B


```{r}
load("./transition_data.RData")
```

### Explore data
```{r}
dim(stateMatrix)
# The amount of sickness and death increase by time
plot(1:3650/365, apply(stateMatrix, 2, mean))

#  Check what percentage of data is in certain states over time
plot(50+1:3650 / 365, apply(stateMatrix, 2, function(x) mean(x==2)))
plot(50+1:3650 / 365, apply(stateMatrix, 2, function(x) mean(x == 1)))
plot(50+1:3650 / 365, apply(stateMatrix, 2, function(x) mean(x == 0)))

# Create state transition dataframe
for (i in 1:dim(stateMatrix)[1]){
    transitions = rle(stateMatrix[i,])
    t = cumsum(transitions$lengths)/365
    state = transitions$values
    s = transitions$lengths/365
    result_df <- data.frame(s = s, from = state, to = c(state[-1], NA),t=t)
    
    # join into a single dataframe
    if (i==1) {
        state_transition_df = result_df
    } else {
        state_transition_df = rbind(state_transition_df, result_df)
    }
}

# Plot some results
state_transition_df %>% 
    filter(from == 2 & to == 1)  %>%
    ggplot(aes(x = t, y = s)) + geom_point() + ggtitle("Healthy to sick")

###### Plot histograms

##### Healthy to sick
state_transition_df %>% 
    filter(from == 2 & to == 1)  %>%
    ggplot(aes(x = s)) + geom_histogram() + ggtitle("Healthy to sick")

# Plot histograms
state_transition_df %>% 
    filter(from == 2 & to == 1)  %>%
    ggplot(aes(x = t)) + geom_histogram() + ggtitle("Healthy to sick")

##### Sick to healthy

# Plot histograms
state_transition_df %>% 
    filter(from == 1 & to == 2)  %>%
    ggplot(aes(x = s)) + geom_histogram() + ggtitle("Healthy to sick")

# Plot histograms
state_transition_df %>% 
    filter(from == 1 & to == 2)  %>%
    ggplot(aes(x = t)) + geom_histogram() + ggtitle("Healthy to sick")


```

# Create MModels
```{r}

# Structure data to be used in glm
state_transition_df$from = as.factor(state_transition_df$from)

# Create glm models exponential 
model_21_s = glm(s ~ 1,family = Gamma(link="log") ,data=state_transition_df %>% filter(from == 2 & to == 1))
model_21_t = glm(t ~ 1,family = Gamma(link="log") ,data=state_transition_df %>% filter(from == 2 & to == 1))
summary(model_21_t)
summary(model_21_s)

# plot fit as histogram
state_transition_df %>% 
    filter(from == 2 & to == 1)  %>%
    ggplot(aes(x = s)) + geom_histogram() + ggtitle("Healthy to sick") + geom_density(aes(y=..density.., color = "density")) + geom_density(aes(y=..count.., color = "count"))

# Create glm models exponential 
model_21_s = glm(s ~ 1,family = Gamma(link="log") ,data=state_transition_df %>% filter(from == 2 & to == 1))
model_21_t = glm(t ~ 1,family = Gamma(link="log") ,data=state_transition_df %>% filter(from == 2 & to == 1))
summary(model_21_t)

# plot fit as histogram
state_transition_df %>% 
    filter(from == 2 & to == 1)  %>%
    ggplot(aes(x = s)) + geom_histogram() + ggtitle("Healthy to sick") + geom_density(aes(y=..density.., color = "density")) + geom_density(aes(y=..count.., color = "count"))



mu12 <- function(t){
    return(50)
}

mu21 <- function(t){
    return(2)
}

```

### Assigment 3

# Set function 
```{r}
library(deSolve)

# define reserve ode
reserves_ode <- function(t, V, par) {
  tt <- par$step 
  dV1 <- (b1(t)-mu(t)*V[1] - mu12(t)*(V[2]-V[1]))*tt + D(t,t+tt)*V[1]
  dV2 <- (-mu(t)*V[2]-mu21(t)*(V[1]-V[2]))*tt +D(t,t+tt)*V[2]
  return(list(c(dV1,dV2)))
}

# define boundary values for the last time point
boundaryValuesEndOfContract <- c(V1 = 0, V2 = 0)     
t_max = 65

```

```{r}
library(deSolve)
# define time points where the function "exampleODE" should be evaluated
timeStep <- 1/365
timePointsBackward <- seq(from = 10, to = 0, by = -timeStep)
timePointsForward <- seq(from = 0, to = 10, by = timeStep)

# define parameters
par <- list(step = abs(timeStep))             # step size needed for indexation

# solve the ODE
odeSol <- ode(times = timePointsBackward, y = boundaryValuesEndOfContract, func = reserves_ode, parms = par)

# have a look at the solutions
plot(timePointsBackward, odeSol[, 2], type = "l", ylim = c(min(odeSol[, 2:3]), max(odeSol[, 2:3])))
lines(timePointsBackward, odeSol[, 3], lty = 2, col = "red")

one_time_premium = odeSol[length(odeSol)]

```

# Calculate dependency on the timestep size
```{r}
reservs_per_timestep <- function(timestep){
    timePointsBackward <- seq(from = 10, to = 0, by = -timestep)
    par <- list(step = abs(timestep))  
    odeSol <- ode(times = timePointsBackward, y = boundaryValuesEndOfContract, func = reserves_ode, parms = par)
    return(odeSol)
}
timesteps = c(1/365, 1/52, 1/12, 1/4, 1/2,1)
reservs <- lapply(timesteps, reservs_per_timestep)
one_time_premiums <- lapply(reservs, function(x) x[length(x)])

# put reserves into a dataframe for plotting
reservs <-  lapply(reservs, function(x) data.frame(x))

ggplot() +
#   geom_line(data = reservs[[1]], aes(x = time, y = V2, color = "daily")) +
  geom_line(data = reservs[[2]], aes(x = time, y = V2, color = "weekly")) +
  geom_line(data = reservs[[3]], aes(x = time, y = V2, color = "monthly")) +
  geom_line(data = reservs[[4]], aes(x = time, y = V2, color = "quarterly")) +
  geom_line(data = reservs[[5]], aes(x = time, y = V2, color = "half-yearly")) +
  geom_line(data = reservs[[6]], aes(x = time, y = V2, color = "yearly")) +
    theme_minimal()
```

# Assigment 4
```{r}

pi <- 10 # Test premium of 100 dollars
b2 <- function(t){
    return(-pi*(1.015^t))
}

timeStep <- 1/365
timePointsBackward <- seq(from = 10, to = 0, by = -timeStep)
timePointsForward <- seq(from = 0, to = 10, by = timeStep)

# define reserve ode
reserves_ode <- function(t, V, par) {
  tt <- t / par$step + 1
  dV1 <- (b1(t)-mu(t)*V[1] - mu12(t)*(V[2]-V[1]))*tt + D(t,t+tt)*V[1]
  dV2 <- (b2(t)-mu(t)*V[2]-mu21(t)*(V[1]-V[2]))*tt +D(t,t+tt)*V[2]
  return(list(c(dV1,dV2)))
}

# solve the ODE
odeSol <- ode(times = timePointsBackward, y = boundaryValuesEndOfContract, func = reserves_ode, parms = par)

# have a look at the solutions
plot(timePointsBackward, odeSol[, 2], type = "l", ylim = c(min(odeSol[, 2:3]), max(odeSol[, 2:3])))
lines(timePointsBackward, odeSol[, 3], lty = 2, col = "red")

```

# Run experimeent as a function of the premium rate
```{r}
reserves_w_premium <- function(pi){
    b2 <- function(t){
        return(-pi*(1.015^t))
    }
    # solve the ODE
    odeSol <- ode(times = timePointsBackward, y = boundaryValuesEndOfContract, func = reserves_ode, parms = par)
}

pis <- c(-1000/365,-2000/365,-5000/365,-10000/365,0,1000/365,2000/365,5000/365,10000/365) # Test premium of 100 dollars
reservs <- lapply(pis, reserves_w_premium)

reservs <-  lapply(reservs, function(x) data.frame(x))

ggplot() +
  geom_line(data = reservs[[1]], aes(x = time, y = V2, color = "-1000")) +
  geom_line(data = reservs[[2]], aes(x = time, y = V2, color = "-2000")) +
  geom_line(data = reservs[[3]], aes(x = time, y = V2, color = "-5000")) +
  geom_line(data = reservs[[4]], aes(x = time, y = V2, color = "-10000")) +
  geom_line(data = reservs[[5]], aes(x = time, y = V2, color = "0")) +
  geom_line(data = reservs[[6]], aes(x = time, y = V2, color = "1000")) +
  geom_line(data = reservs[[7]], aes(x = time, y = V2, color = "2000")) +
  geom_line(data = reservs[[8]], aes(x = time, y = V2, color = "5000")) +
  geom_line(data = reservs[[9]], aes(x = time, y = V2, color = "10000")) +
    theme_minimal()


```


# Assigment 5

```{r}

n_bootstraps = 100
par <- list(step = abs(timeStep)) 

# define reserve ode
reserves_ode <- function(t, V, par) {
  tt <- t / par$step + 1
  dV1 <- D(t,tt)*V[1]+b1(t)*tt-mu(t)*V[1]*tt - mu12(t)*(V[2]-V[1])*tt
  dV2 <- D(t,tt)*V[2]-mu(t)*tt*V[2]-mu21(t)*(V[1]-V[2])*tt
  return(list(c(dV1,dV2)))
}
timeStep <- 1/365
timePointsBackward <- seq(from = 10, to = 0, by = -timeStep)
timePointsForward <- seq(from = 0, to = 10, by = timeStep)

for i in 1:n_bootstraps{
    bootsstraps = sample(state_transition_frequency)

    # Apply the function to each row of the stateMatrix
    s1_to_s2 <- apply(stateMatrix, 1, function(x) {
        state_transition_frequency(x, 2,1)
    })
    hist(unlist(s1_to_s2)/365)


    # Apply the function to each row of the stateMatrix
    s2_to_s1 <- apply(stateMatrix, 1, function(x) {
        state_transition_frequency(x, 2,1)
    })

    mu12 <- function(t){
        return(50)
    }

    mu21 <- function(t){
        return(2)
    }

    # solve the ODE
    odeSol <- ode(times = timePointsBackward, y = boundaryValuesEndOfContract, func = reserves_ode, parms = par)

    one_time_premium = odeSol[length(odeSol)]

}

```
